变量定义
一般形式为{类型名称}{变量名称}
int price;
int amount;
Int price,amount;
标识符只能由字母，数字和下划线组成，数字不可以出现在第一个位置上，Java关键字不可以做标识符
INT price =0；变量名字是price 类型int 初始值是0
所有变量必须定义或声明 所有变量有确定数据类型，数据类型表示在变量中存放什么样的数据，变量存放指定类型数据。运行过程中不能改变变量类型
浮点数：带小数点的数值
Double 双精度浮点数类型
强制类型转换 ex：int i=（int）（32/3.0）
优先级 判断是否相等的==和！=的优先级比其他的低，而连续的关系运算从左到右进行的
嵌套的判断 当if的条件满足或不满足要执行的语句也可以是一条if或if-else语句。这就是嵌套的if语句。
If（code == ready）
   If(count<20)

   Else
      SYS

Switch-case

控制表达式只能是整数型的结果
常量可以是常数，也可以是常数计算的表达式
根据表达式结果，寻找匹配的case，并执行case后面的语句，一直到break为止
如果所有case不匹配，就执行default后面的语句，如没有，就什么都不做

Switch (控制表达式) {
Case 常量：
      语句
.....
Case 常量：
语句
.....
Default：
     语句
     ....
}

while循坏 当条件满足时，不断地重复循环体内的语句。 循环执行之前判断是否继续循环，
可能循环一次也没有执行
 do-while循环 先执行完一轮代码之后，再检查条件是否满足，如满足则做下一轮循环，反
 之结束。
 do{
   循环语句
 } while(条件);

 for循环
 for（初始化；条件；单步动作）{
 } 第一个部分是初始化，可以定义一个新的变量，或直接赋值。第二个部分是循环维持的条件。
 与while循环一样，条件满足才循环；条件不满足就结束循环。第三个部分是步进。执行力循环体之后
 必须执行的表达式。在这里改变循环变量，进行加或减的操作
 for（初始条件；条件；每轮的动作）{
 } for中的每一个表达式都是可以省略的
 for（；条件；） == while（条件）
 如果有固定次数 用FOR 如果必须执行一次 用do_while 其他情况用while

 break 跳出循环
 continue 跳过循环进入下一轮
可带入标号来表示循环 break和continue起作用对标号


|| 或 &&与  !非 优先级！>&&>||

数组 是一种容器 特点是 所有元素有相同数据类型 一旦创建，不能改变大小
 定义数组变量 <类型>{}<名字> = new <类型>[元素个数];
元素个数必须是整数
元素个数必须给出
元素个数是变量 length表示长度
数组变量是数组管理者而非数组本身，数组必须创建出来交给数组变量来管理，数组变量之间赋值是管理权限授予。数组变量之间比较判断是否管理同一个数组
遍历数组 通常使用for循环，让循环变量I从0到<数组的length 常见错误：循环结束条件是<=数组长度，离开循环后，用I的值做数组元素的下标；
for-each for(<类型><变量>:<数组>){
   }


二维数组
int [][] a =new int[3][5]; 理解为a是一个3行5列的矩阵
int[][] a={{1,2,3,4},{1,2,3,},} 编译器数数，每行一个{}，逗号分隔

逃逸(转义)字符 \b回退一格 \t到下一个表格 \n换行 \r回车 \"双引号 \'单引号 \\本身

包裹类型 每种基础类型有对应包裹类型 用处：获得该类型的最大最小值
. 运算符 当需要让一个类或对象做事请，用.运算符

字符串变量 String s; String是一个类，变量是对象的管理者而非所有者 String s = new String("a str");创建了一个string对象 也可以初始化字符串变量String s ="hellpo";
用+号可以连接两个字符串 当+一边是字符串而另一边不是，将另一边表达为字符串做链接； Strings 用equal来比较是否相等 用==比较内容
字符串操作通过.运算符来进行 可以是常量也可以是变量 字符串大小比较是s1.compareto(s2)  获得长度length()函数。访问String里字符s.charAt(index)返回
在index上单个字符 范围是0到length（）—1 得到子串 s.substring(n)得到从N号位置到末尾的全部内容 s.substring(b,e)得到从b号位置到e号位置之前内容
s.indexof() 寻找字符 所有对字符串操作都不会改变字符串本身内容

函数是一块代码，接受零个或多个参数，做一件事情并返回值
public static（函数头） void（返回类型） Function（函数名）(a,b) （参数）
{
   函数体
}
调用函数 函数名（参数值） （）起到了表示函数调用的重要作用 没有参数也要（） 如果有参数 ，需要给出正确数量和顺序
值会按照顺序用来初始化函数参数
从函数中返回值 return停止函数执行，并送回一个值。return；return 表达式；
没有返回值的函数 void 函数名（参数表） 不能使用带值的return 可以没有return。调用不能做返回值的赋值
调用函数 如果函数有参数，必须给他数量，类型正确的值
如果类型不匹配，当参数比给的值类型宽时，char——int——double 当参数比给的值窄，需要强化类型转换。当参数与值无法转换就不行
Java在调用函数时，永远只能传值给函数。每个函数有自己的变量空间，参数位于独立空间，与其他函数没有关系。

本地变量
函数每次运行，产生独立变量空间。在这空间变量是独有的，称为本地变量。定义在函数内部的变量是本地变量。参数也是本地变量
变量生存期和作用域是大括号内——快
本地变量规则
本地变量是定义在块内，函数块内，语句块内，甚至是一对大括号内，程序在进入这个快前，变量不存在，离开这个快，变量消失了。块外面定义变量依然有效。不能定义
在一个快内同名的变量，也不能定义在快外面定义过的变量。本地变量不会被默认初始化。参数在进入函数就被初始化了


对象与类
对象是实体，需要创建。类是规范，根据类定义来创建对象
对象 ：表达东西或事件。运行时响应信息。类：定义所有属性，就是java中类型，用来定义变量
对象=属性+服务 数据：属性或状态。操作：函数 把数据和对数据操作放在一起=封装
面向对象特性 1.一切都是对象。2.程序是一堆互相发送信息的对象 3每个对象有自己存储空间，里面是其他对象4每个对象有一个类型5所有属于每个特定类型对象可以提供共
相同服务

创建对象
类.变量 =new 类；
匿名对象的使用：1.我们创建的对象，没有显示的赋给一个变量名。即为匿名对象。2.特征：匿名对象只能使用一次
对象变量是对象的管理者
成员变量 类定义了对象中具有变量，这些变量称为成员变量。每个对象有自己变量，和同一个类其他对象是分开的
在函数中可以直接写成员变量名字来访问成员变量，函数是通过对象来调用的。v.insetmoney()这次调用建立insertmonet和v之间关系，让insertmoney内部成员变量
值得是v的成员变量
this 是成员函数一个特殊的固有本地变量，他表达了调用这个函数的那个对象
调用函数 通过.运算符调用某个对象函数。在成员函数内部直接调用自己（this）的 其他函数
本地变量 定义在函数内部的变量是本地变量。本地变量的生存期和作用域都是函数内部。成员变量的生存期是对象的生存期，作用域是类内部的成员函数
对象初始化 成员变量定义初始化。
成员变量在定义的地方就可以给出初始值。没有给出初始值的成员变量会自动获得0值。对象变量的0值没有管理任何对象，也可以主动给null值。定义初始化可以调用函数
甚至可以使用已经定义的成员变量

构造函数 如有一个成员函数名字和类名字完全相同，则在创建这个类的每一个对象会自动调用这个函数——构造函数，这个函数值不能有返回类型。
JavaBean：一种JAVA语言写成的可重用租件。符合以下的java类：类是公共的，有一个无参的公共的构造器，有属性，且有对应的get和set方法。用户可以使用JAVABEAN将功能，处理，值，数据库访问和其他任何可以用
java代码创造对象进行打包，其他开发者可以通过内部jsp页面，servlet，其他javabean，applet程序来使用这些对象。

函数重载 一个类可以有多个构造函数，只要他们参数表不同。创建对象的时候给出不同的参数值，就会调用不同的构造函数。通过this（）可以调用其他构造函数。 两同一不同:同一个类，同一个方法名，参数列表不同:参数个数不同，参数类型不同
一个类里的同名但参数表不同函数构成了重载关系，判断是否重载：跟方法的权限修饰符，返回值类型，形参变量名，方法体都没有关系
可变个数形参的方法（JDK5)用法：1.格式：数据格式...变量名 2.当调用方法时，传入参数个数：0，1,2 3.当方法与本类中方法名相同，形参不同方法之间构成重载
4.方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。5.可便个数形参在方法的形参中,必须声明在末尾 6.可变变数形参在方法的形参中,最多只能声明一个可变形参

封装 为了追求低耦合，高内聚：操作细节自己完成，不允许外部干涉
private 只有这个类内部可以访问，类内部指定类的成员函数和定义初始化。这个限制是对类的而不是对象
public 任何人都可以访问，指的是任何类的函数或定义初始化中可以使用。使用指的是调用，访问或定义变量
static 修饰类变量，一个对象改变了类变量的值，这个类变量的值都会发生改变，
static 修饰类函数 static里只能调用static的函数，只能访问static的成员变量


对象容器
Arraylist<String> notes=new Arraylist<String>
容器类有两个类型：容器的类型，元素的类型
对象数组 对象数组中每个元素都是对象的管理者而非对象本身
for——each循环对于对象数组循环来说，可以改变管理的对象 对象数组初始化可以用for——each
set 集合容器 类似与数学中的集合
hash 散列表 使用for——each循环 用keyset来遍历；

继承与多态
我们把用来做基础派生其它类的那个类叫做父类、超类或者基类，而派生出来的新类叫做子类。Java用关键字extends表示这种继承/派生关系：
class ThisClass extends SuperClass {
    //…
}
不同访问属性的父类成员在子类中的访问属性：public 对所有人开放。protected 在父类中，只有包类其他类，自己和子类可以访问。default 只有包内其他类可以访问
private 只有自己可以访问,其实父类可以获取子类的私有结构方法，但由于封装性影响，使得子类不能调用父类的结构
一个变量可以保存其所声明的类型或该类型的任何子类型。
子类和子类型 类定义了类型，子类定义了子类型，子类的对象可以被当作父类的对象来使用：赋值给父类的变量，传递给需要父类对象的函数，放进存放父类对象的容器
子类的对象可以赋值给父类的变量。子类的对象可以传递给需要父类对象的函数。
多态变量
java的对象变量是多态的，他们能保存不止一种类型的对象。他们可以保存是声明类型的对象，或声明类型的子类的对象。当把子类的对象赋给父类的变量时候，就发生了
向上造型
造型cast
子类的对象可以赋值给父类的变量 ！注意Java中不存在对象给对象的赋值。父类的对象不能赋值给子类的变量。可以用造型。
造型
用括号围起类型放在值的前面，对象本身并没有发生任何变化，所以不是类型转换。运行时有机制来检查这样转化是否合理，ClassCastexpection
函数调用的绑定 当通过对象变量调用函数的时候，调用函数这件事情叫做绑定。静态绑定：根据变量的声明类型来绑定，动态绑定：根据变量的动态类型来决定。
在成员函数中调用其他成员函数也是通过this这个对象变量来调用的。

覆盖override 子类和父类中存在名称和参数表完全相同的函数，这一对函数构成覆盖关系。通过父类的变量调用存在关系的函数时，会调用变量当时所管理的对象所属的类
的函数.子类继承父类以后，可对父类中同名同参数的方法，进行覆盖操作。
重写以后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法
重写的规定：约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
1.子类重写的方法方法名和形参列表与父类被重写的方法的方法名和形参列表相同.2.子类重写的放法的权限修饰符不小于父类被重写的方法的权限修饰符.特殊情况:子类不能重写父类中声明private权限的方法.
3.返回值类型:父类被重写的返回值类型是void,子类重写的方法的返回值只能是void.父类被重写方法的返回值类型是A类型,则子类重写方法的返回值类型可以是A类或A的子类
父类被重写的方法的返回值类型是基本数值类型,则子类重写方法的返回值类型必须是相同类型
子类和父类中同名同参数的方法要么声明为非static,要么声明为static

设计原则
消除代码复制，增加可拓展性。 用封装来降低耦，类和类之间的关系称作耦合，耦合越低越好，保持距离是形成良好代码的关键。用接口来实现聚合。用容器和实现灵活性
以框架+数据来提高可拓展性。命令的解析是否脱离if——else。定义一个类来处理命令。用框架来保存命令与类之间关系
数据与表现分离。程序的业务逻辑与表现无关：表现可以是图形的也可以是文本的，表现可以是当地的也可以是远程的。
责任驱动的设计，将程序要实现的功能分配到合适的类或对象中去是设计中非常重要的一环。
网格化

抽象与接口
抽象函数-表达概念而无法实现具体代码的函数。抽象类-表达概念而无法构造出实体的类。
带有abstract修饰符的函数，有抽象函数的类一定是抽象类，抽象类不能制造对象，但是可以定义变量，任何继承了抽象类的非抽象类的对象可以付给这个变量。
实现抽象函数，继承自抽象类的子类必须覆盖父类中的抽象函数，否则自己成为抽象类
两种抽象，与具体相对：表示一种概念而非实体。与细节相对：表示在一定程度上忽略细节而着眼大局
接口
接口是纯抽象类，所有的成员函数都是抽象函数，所有的成员变量都是public static final
接口规定了长什么样，但是不管里面有什么 用关键字 implements关联
实现借口
类用extends，接口用implements，类可以实现很多接口。接口可以继承接口，但不能继承类。接口不能实现接口。
面向接口的编程方式
设计程序时先定义接口，再实现类。任何需要再函数间传入传出的一定是接口而不是具体的类。

Swing使用一个非常灵活的模型来处理GUI的输入:采用事件监听器的事件处理(event handling)模型。
Swing框架本身以及大部分部件在发生一些情况时会触发相关的事件,而其他的对象也许会对这些事件感兴趣。不同类型的动作会导致不同类型的事件。
当点击一个按钮或选中一个菜单项,部件就会触发动作事件;而当点击或移动鼠标时,会触发鼠标事件;当框架被关闭或最小化时,会触发窗口事件。另外还有许多种其他事件
内部类就是指一个类定义在另一个类的内部，从而成为外部类的一个成员。因此一个类中可以有成员变量、方法，还可以有内部类。
实际上Java的内部类可以被称为成员类，内部类实际上是它所在类的成员。所以内部类也就具有和成员变量、成员方法相同的性质。
比如，成员方法可以访问私有变量，那么成员类也可以访问私有变量了。也就是说，成员类中的成员方法都可以访问成员类所在类的私有变量。内部类最重要的特点就是能够访问外部类的所有成员。
mi名类 在new对象的时候给出的类的定义形成了mi名类。可以继承某类，也可以实现某接口。Swing的消息机制广泛使用mi名类
内部类
定义在别的类内部，函数内部的类。内部类能直接访问外部的全部资源：包括任何私有的成员，外部是函数时，只能访问那个函数final的那个变量
注入反转
由按钮公布一个守听者接口和一对注册/注销函数，你的代码实现接口，将守听者对象注册在按钮上。一旦按钮被按下，就会反过来调用你的守听者对象的某个函数

JTABLE
用Jtable类可以以表格的形式显示和编辑数据，jtable类的对象并不存储数据，他只是数据的表现
MVC控制模式
数据，表现和控制三者分离，各负其责
M=model 模型 V=view（表现）C=control（控制） 模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新。表现：从模型获得数据
根据数据画出表现。控制：从用户得到输出，根据输入调整数据

异常处理与输入
异常 捕捉异常
try{
   // 可能产生代码的异常
}catch (type1 id1){
   // 处理type1异常的代码
} catch (type2 id2){
   // 处理type1异常的代码
} catch（type3 id3）{
   // 处理type1异常的代码
}
异常捕获机制
有异常抛出——所处的是try 如是 看有catch匹配 如有 则继续下面的语句。如否 则推出到外层。 如所处的不是try，看所处的是否是函数
如是 则返回调用者，在判断是否所处的是try，在返回所处的是try。如所处的函数不是则退出到外层 。在判断所处的是否是try
拿到异常对象之后 String getMessage（）；String toString（）；void printStackTrace（）；
再度抛出异常 catch（exception e）{
   throw e；
}如果在这个层面上需要处理，但是不能做最终的决定
异常：有不寻常的事情发生了。当这个事情发生的时候，原本打算要接着做的事情不能在继续了，必须要停下来，让某个地方的某段代码来处理
异常机制最大的好处就是清晰的分开了正常的业务逻辑代码和遇到情况时的处理代码
异常声明
如果你的函数可能抛出异常，就必须在函数头部加以声明 void f() throws toobig，toosmall{ //...
}  void f（）{...}  可以声明并不会真的抛出异常
异常声明 如果你调用一个声明会抛出异常的函数，那么：把函数的调用放在try块中，并设置Catch来捕捉所有可能抛出的异常，或声明自己
会抛出无法处理的异常。
异常声明遇到继承关系：当覆盖一个函数的时候，子类不能声明抛出比父类版本更多的异常。在子类的构造函数中，必须声明父类可能抛出的全部异常
throws的对象 ：任何继承了Throwable类的对象。Exception类继承了Throwable，thow new Exception（）；throw new Exception（"helo"）
catch怎么匹配到异常的 Is——A的关系，抛出子类异常会被捕捉到父类异常的Catch给捉到
捕捉到任何异常Catch（EXCEPTION E){
   ...
}
运行时刻异常 有些异常是不需要声明的，但是如果没有适当机制来捕捉，就会导致程序终止。

流
流是输入输出的方式，流是一维单向的。
流的基础类：inputstream(read()...)，outputstream(write()...)
文件流
FileinputStream,FileoutputStream 对文件作读写操作，实际工程中很少使用，最常用的是在内存数据或通信数据上建立的流，如数据库的
二进制数据读写或网络端口通信。具体的文件读写往往有更专业的类，比如配置文件和日志文件
流过滤器
以一个介质流对象为基础层层构建过滤器流，最终形成的流对象能在数据的输入输出过程中，逐层使用过滤器流的方法来读写数据
Data DatainputStream DataoutputStream 用以读写二进制方式表达的基本数据类型的数据
文本输入输出
Reader/Writer 二进制数据采用inputStream/outputstream 文本数据采用Reader/Writer
在流上建立文本处理 printWriter pw = new printwriter（new bufferedwriter（new outputStreamwriter（new FileoutputStream（））
Reader 常用的时BUFFEREDReader: readline（）
LINENUMBERREADER 可以得到行号：getlinenumber（）
FILEREADER：inputStreamReader类的子类，所有方法都从父类中继承而来
FileReader（File file） 在给定从中读取数据的File的情况下创建一个新的FileReader
FileReader（String Filename） 在给定从中读取数据的文件名情况下创建一个新FileReader
fileREADER不能指定编码转换方式
汉字编码
inputStreamReader(inputstream in) 创建一个使用默认字符集的inputSTREmreader
inputStreamReader(inputstream in，Charset cs) 创建使用给定字符集的inputstreamreader
inputStreamReader(inputstream in，CharsetDecoder dec) 创建使用给定字符集解码器的inputstreamreader
inputStreamReader(inputstream in，String charsetName) 创建使用指定字符集的 inputstreamreader
数据是二进制的 用InputSream 表达的是文本 用Reader 否则用Scanner

流的应用
阻塞/非阻塞
read（）函数是阻塞的，在读到所需的内容之前会停下来等。使用read（）的更高级的函数 都是这样
常用单独线程来做socket读的等待，或使用nio的channel机制
对于socket可以设置SO时间 setsoTINEout（INT timeout）

Maven构建工具
由于jar包添加麻烦或工作量大。可以自动帮程序员下载第三方库（jar），完成整个项目编译（调用javac.exe），完成整个项目单元测试流程（调用junit工具），完成项目打包（调用jar.exe)
maven是一个构建工具，自动下载中心仓库的jar文件，存在本地进行管理，编译，测试，运行和打包发布java项目
Maven构建生命周期：清理，编译，测试，打包，安装，部署

单元测试和JUNIT
测试
软件测试的经典定义：在规定的条件下对程序进行操作，以发现程序错误，并对其能满足设计要求进行评估的过程

单元和集成测试
单元测试，对软件中的最小可测试单元进行检测和验证，通常是一个函数/方法。单元测试是已知代码结构进行的测试，属于白盒测试。
集成测试是多个单元相互作用，形成一个整体，对整体协调性进行测试。一般从构成系统的最小单元开始，持续推进到单元之间的接口直到集成为一个完成的软件系统为止。

白盒和黑盒测试
白盒测试，全面了解程序内部逻辑结构，对所有的逻辑路径进行测试，一般由程序员完成。
黑盒测试，在完全不考虑此程序内部结构和内部特性的情况下，检查程序功能是否按照需求规格说明书的规定正常使用，一搬由独立的使用者完成。

自动和手动测试
自动测试：用程序批量反复测试程序，并可自动检查程序结果是否满足预定的要求
手动测试：手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求

回归测试
回归测试：修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误
回归测试在整个软件的是过程中占有很大比重。软件快速迭代开发过程中，新版本的连续发布使得回归测试进行的更加频繁
测试策略
基于main函数的策略
优点：简单 缺点：无法自动判断被测对象的行为是否符合预期。main方法需要添加大量的代码。分散程序员在开发时的关注点
基于自动化测试框架的策略
初始化，输入测试数据执行被测代码，获取系统实际结果，比较结果是否一致，输出测试结论
JUnit：一个Java语言的单元测试框架
import static：导入某一个类的所有静态方法；import是导入一个类或者几个类

高级文本处理
字符编码:字符，ASCII码：用一个字节来存储a-z，A-Z，0-9和一些常用符号。回车键（13，00001101），0（48，00110000），A（65，01000001），a（97，01100001）
ASCII编码采用1bit，8bit，最多256个字符
中文编码：GB2312,GBK,GB18030,BIG5,GB18030>GBK>GB2312
UNICODE编码：存储全世界所有字符。编码方案：UTF-8，兼容ASCII，变长。UTF-16.用2-4个字节存储所有字符。UTF-32，用32Bits存储所有字符
JAVA的字符编码：源文件编码：采用UTF-8编码。程序采用UTF-16编码存储所有字符。和\

Java国际化编程
多语言版本的软件：一套软件，多个语言包。根据语言设定，可以切换显示文本。
Java是第一个设计成支持国际化的编程语言。java.util.ResourceBundle 用于加载一个语言-国家语言包。java.util.Locale定义一个语言-国家
Locale类
Locale语言，zh，en等。Locale方法：getAvailableLocales()返回所有可用的Locale。getDefault（）返回默认的Locale
语言文件
一个properties文件，包含K-V对，每行一个K-V。命名规则：包名+语言+国家地区.properties。存储文件必须是ASCII文件，如果是这以外文件，必须用Unicode的表示。可以用native2ascii.exe进行转码
ResourceBundle类
根据Locale要求，加载语言文件。存储语言集合中所有K-V对。getString返回对应的Value。根据key找value的查找路径。
Locale：由语言和国家/地区组合起来的。所有的PROPERTIES文件形成一个树。指定Locale后，ResourceBundle就形成一个树：先找到第一个节点文件（搜索路径），将该节点所有父节点文件全部加载。根据所找到的文件内容和KeY,返回相应的值
其他国际化：日期/时间国际化DateTimeFormatter和Locale的结合。数字/金融国际化.NumberFORmat和Locale结合

Java高级字符串处理
正则表达式：用事先定义好的一些特定字符及特定字符的集合，组成一个“规则字符串”，作用：测试字符串内的模式，识别替换文本。提取文本。正则表达式独立于特定语言。
Java.util.regex包：-pattern正则表达式的编译显示，–Pattern 正则表达式的编译表示
• compile 编译一个正则表达式为Pattern对象
• matcher 用Pattern对象匹配一个字符串，返回匹配结果
–Matcher
• Index Methods(位置方法) // start(), start(int group), end(), end(int group)
• Study Methods(查找方法) // lookingAt(), find(), find(int start), matches()
• Replacement Methods(替换方法) //replaceAll(String replacement
字符串和集合互转
–[1,2,3], “1,2,3”
• 字符串转义
–对关键字符转义
• 变量名字格式化
–名字驼峰命名
• 字符串输入流
–将字符串转为一个输入流
–输入流可以定义为Scanner，这是Online Judge的实现原理

