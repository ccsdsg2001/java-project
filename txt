变量定义
一般形式为{类型名称}{变量名称}
int price;
int amount;
Int price,amount;
标识符只能由字母，数字和下划线组成，数字不可以出现在第一个位置上，Java关键字不可以做标识符
INT price =0；变量名字是price 类型int 初始值是0
所有变量必须定义或声明 所有变量有确定数据类型，数据类型表示在变量中存放什么样的数据，变量存放指定类型数据。运行过程中不能改变变量类型
浮点数：带小数点的数值
Double 双精度浮点数类型
强制类型转换 ex：int i=（int）（32/3.0）
优先级 判断是否相等的==和！=的优先级比其他的低，而连续的关系运算从左到右进行的
嵌套的判断 当if的条件满足或不满足要执行的语句也可以是一条if或if-else语句。这就是嵌套的if语句。
If（code == ready）
   If(count<20)

   Else
      SYS

Switch-case

控制表达式只能是整数型的结果
常量可以是常数，也可以是常数计算的表达式
根据表达式结果，寻找匹配的case，并执行case后面的语句，一直到break为止
如果所有case不匹配，就执行default后面的语句，如没有，就什么都不做

Switch (控制表达式) {
Case 常量：
      语句
.....
Case 常量：
语句
.....
Default：
     语句
     ....
}

while循坏 当条件满足时，不断地重复循环体内的语句。 循环执行之前判断是否继续循环，
可能循环一次也没有执行
 do-while循环 先执行完一轮代码之后，再检查条件是否满足，如满足则做下一轮循环，反
 之结束。
 do{
   循环语句
 } while(条件);

 for循环
 for（初始化；条件；单步动作）{
 } 第一个部分是初始化，可以定义一个新的变量，或直接赋值。第二个部分是循环维持的条件。
 与while循环一样，条件满足才循环；条件不满足就结束循环。第三个部分是步进。执行力循环体之后
 必须执行的表达式。在这里改变循环变量，进行加或减的操作
 for（初始条件；条件；每轮的动作）{
 } for中的每一个表达式都是可以省略的
 for（；条件；） == while（条件）
 如果有固定次数 用FOR 如果必须执行一次 用do_while 其他情况用while

 break 跳出循环
 continue 跳过循环进入下一轮
可带入标号来表示循环 break和continue起作用对标号


|| 或 &&与  !非 优先级！>&&>||

数组 是一种容器 特点是 所有元素有相同数据类型 一旦创建，不能改变大小
 定义数组变量 <类型>{}<名字> = new <类型>[元素个数];
元素个数必须是整数
元素个数必须给出
元素个数是变量 length表示长度
数组变量是数组管理者而非数组本身，数组必须创建出来交给数组变量来管理，数组变量之间赋值是管理权限授予。数组变量之间比较判断是否管理同一个数组
遍历数组 通常使用for循环，让循环变量I从0到<数组的length 常见错误：循环结束条件是<=数组长度，离开循环后，用I的值做数组元素的下标；
for-each for(<类型><变量>:<数组>){
   }


二维数组
int [][] a =new int[3][5]; 理解为a是一个3行5列的矩阵
int[][] a={{1,2,3,4},{1,2,3,},} 编译器数数，每行一个{}，逗号分隔

逃逸(转义)字符 \b回退一格 \t到下一个表格 \n换行 \r回车 \"双引号 \'单引号 \\本身

包裹类型 每种基础类型有对应包裹类型 用处：获得该类型的最大最小值
. 运算符 当需要让一个类或对象做事请，用.运算符

字符串变量 String s; String是一个类，变量是对象的管理者而非所有者 String s = new String("a str");创建了一个string对象 也可以初始化字符串变量String s ="hellpo";
用+号可以连接两个字符串 当+一边是字符串而另一边不是，将另一边表达为字符串做链接； Strings 用equal来比较是否相等 用==比较内容
字符串操作通过.运算符来进行 可以是常量也可以是变量 字符串大小比较是s1.compareto(s2)  获得长度length()函数。访问String里字符s.charAt(index)返回
在index上单个字符 范围是0到length（）—1 得到子串 s.substring(n)得到从N号位置到末尾的全部内容 s.substring(b,e)得到从b号位置到e号位置之前内容
s.indexof() 寻找字符 所有对字符串操作都不会改变字符串本身内容

函数是一块代码，接受零个或多个参数，做一件事情并返回值
public static（函数头） void（返回类型） Function（函数名）(a,b) （参数）
{
   函数体
}
调用函数 函数名（参数值） （）起到了表示函数调用的重要作用 没有参数也要（） 如果有参数 ，需要给出正确数量和顺序
值会按照顺序用来初始化函数参数
从函数中返回值 return停止函数执行，并送回一个值。return；return 表达式；
没有返回值的函数 void 函数名（参数表） 不能使用带值的return 可以没有return。调用不能做返回值的赋值
调用函数 如果函数有参数，必须给他数量，类型正确的值
如果类型不匹配，当参数比给的值类型宽时，char——int——double 当参数比给的值窄，需要强化类型转换。当参数与值无法转换就不行
Java在调用函数时，永远只能传值给函数。每个函数有自己的变量空间，参数位于独立空间，与其他函数没有关系。

本地变量
函数每次运行，产生独立变量空间。在这空间变量是独有的，称为本地变量。定义在函数内部的变量是本地变量。参数也是本地变量
变量生存期和作用域是大括号内——快
本地变量规则
本地变量是定义在块内，函数块内，语句块内，甚至是一对大括号内，程序在进入这个快前，变量不存在，离开这个快，变量消失了。块外面定义变量依然有效。不能定义
在一个快内同名的变量，也不能定义在快外面定义过的变量。本地变量不会被默认初始化。参数在进入函数就被初始化了


对象与类
对象是实体，需要创建。类是规范，根据类定义来创建对象
对象 ：表达东西或事件。运行时响应信息。类：定义所有属性，就是java中类型，用来定义变量
对象=属性+服务 数据：属性或状态。操作：函数 把数据和对数据操作放在一起=封装
面向对象特性 1.一切都是对象。2.程序是一堆互相发送信息的对象 3每个对象有自己存储空间，里面是其他对象4每个对象有一个类型5所有属于每个特定类型对象可以提供共
相同服务

创建对象
类.变量 =new 类；
匿名对象的使用：1.我们创建的对象，没有显示的赋给一个变量名。即为匿名对象。2.特征：匿名对象只能使用一次
对象变量是对象的管理者
成员变量 类定义了对象中具有变量，这些变量称为成员变量。每个对象有自己变量，和同一个类其他对象是分开的
在函数中可以直接写成员变量名字来访问成员变量，函数是通过对象来调用的。v.insetmoney()这次调用建立insertmonet和v之间关系，让insertmoney内部成员变量
值得是v的成员变量
this 是成员函数一个特殊的固有本地变量，他表达了调用这个函数的那个对象
调用函数 通过.运算符调用某个对象函数。在成员函数内部直接调用自己（this）的 其他函数
本地变量 定义在函数内部的变量是本地变量。本地变量的生存期和作用域都是函数内部。成员变量的生存期是对象的生存期，作用域是类内部的成员函数
对象初始化 成员变量定义初始化。
成员变量在定义的地方就可以给出初始值。没有给出初始值的成员变量会自动获得0值。对象变量的0值没有管理任何对象，也可以主动给null值。定义初始化可以调用函数
甚至可以使用已经定义的成员变量

构造函数 如有一个成员函数名字和类名字完全相同，则在创建这个类的每一个对象会自动调用这个函数——构造函数，这个函数值不能有返回类型。
JavaBean：一种JAVA语言写成的可重用租件。符合以下的java类：类是公共的，有一个无参的公共的构造器，有属性，且有对应的get和set方法。用户可以使用JAVABEAN将功能，处理，值，数据库访问和其他任何可以用
java代码创造对象进行打包，其他开发者可以通过内部jsp页面，servlet，其他javabean，applet程序来使用这些对象。

函数重载 一个类可以有多个构造函数，只要他们参数表不同。创建对象的时候给出不同的参数值，就会调用不同的构造函数。通过this（）可以调用其他构造函数。 两同一不同:同一个类，同一个方法名，参数列表不同:参数个数不同，参数类型不同
一个类里的同名但参数表不同函数构成了重载关系，判断是否重载：跟方法的权限修饰符，返回值类型，形参变量名，方法体都没有关系
可变个数形参的方法（JDK5)用法：1.格式：数据格式...变量名 2.当调用方法时，传入参数个数：0，1,2 3.当方法与本类中方法名相同，形参不同方法之间构成重载
4.方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。5.可便个数形参在方法的形参中,必须声明在末尾 6.可变变数形参在方法的形参中,最多只能声明一个可变形参

封装 为了追求低耦合，高内聚：操作细节自己完成，不允许外部干涉
private 只有这个类内部可以访问，类内部指定类的成员函数和定义初始化。这个限制是对类的而不是对象
public 任何人都可以访问，指的是任何类的函数或定义初始化中可以使用。使用指的是调用，访问或定义变量
static 修饰类变量，一个对象改变了类变量的值，这个类变量的值都会发生改变，
static 修饰类函数 static里只能调用static的函数，只能访问static的成员变量，多个对象共享同一个静态变量，通过某一个对象修改静态变量时，会导致其他对象调用静态变量时，是修改过的，无法使用this（）super（）关键字
静态变量随着类的加载而加载，静态变量的加载早于对象的创建，在内存中只存在一份，存在方法区的静态域中。


对象容器
Arraylist<String> notes=new Arraylist<String>
容器类有两个类型：容器的类型，元素的类型
对象数组 对象数组中每个元素都是对象的管理者而非对象本身
for——each循环对于对象数组循环来说，可以改变管理的对象 对象数组初始化可以用for——each
set 集合容器 类似与数学中的集合
hash 散列表 使用for——each循环 用keyset来遍历；

继承与多态
对象的多态性：父类的引用指向子类的对象
多态的使用：当调用子父类同名的同参数的方法，实际执行的子类重写父类的方法--虚拟方法调用。声明谁调用谁，
我们把用来做基础派生其它类的那个类叫做父类、超类或者基类，而派生出来的新类叫做子类。Java用关键字extends表示这种继承/派生关系：
class ThisClass extends SuperClass {
    //…
}
不同访问属性的父类成员在子类中的访问属性：public 对所有人开放。protected 在父类中，只有包类其他类，自己和子类可以访问。default 只有包内其他类可以访问
private 只有自己可以访问,其实父类可以获取子类的私有结构方法，但由于封装性影响，使得子类不能调用父类的结构
一个变量可以保存其所声明的类型或该类型的任何子类型。
子类和子类型 类定义了类型，子类定义了子类型，子类的对象可以被当作父类的对象来使用：赋值给父类的变量，传递给需要父类对象的函数，放进存放父类对象的容器
子类的对象可以赋值给父类的变量。子类的对象可以传递给需要父类对象的函数。
多态变量
java的对象变量是多态的，他们能保存不止一种类型的对象。他们可以保存是声明类型的对象，或声明类型的子类的对象。当把子类的对象赋给父类的变量时候，就发生了
向上造型
如何才能调用子类特有的属性和方法？造型：使用强制类型转换符
instanceof关键字的使用：a instance A：判断对象a是否类A的实例，如果是，返回true，如果不是，返回false
如果a instance of A返回true，则a instance B也返回true 其中，类B是类A的父类
造型cast
子类的对象可以赋值给父类的变量 ！注意Java中不存在对象给对象的赋值。父类的对象不能赋值给子类的变量。可以用造型。
造型
用括号围起类型放在值的前面，对象本身并没有发生任何变化，所以不是类型转换。运行时有机制来检查这样转化是否合理，ClassCastexpection，编译时看左边，运行时看右边
函数调用的绑定 当通过对象变量调用函数的时候，调用函数这件事情叫做绑定。静态绑定：根据变量的声明类型来绑定，动态绑定：根据变量的动态类型来决定。
在成员函数中调用其他成员函数也是通过this这个对象变量来调用的。

覆盖override 子类和父类中存在名称和参数表完全相同的函数，这一对函数构成覆盖关系。通过父类的变量调用存在关系的函数时，会调用变量当时所管理的对象所属的类
的函数.子类继承父类以后，可对父类中同名同参数的方法，进行覆盖操作。
重写以后，当创建子类对象以后，通过子类对象调用父类中同名同参数的方法时，实际执行的是子类重写父类的方法
重写的规定：约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
1.子类重写的方法方法名和形参列表与父类被重写的方法的方法名和形参列表相同.2.子类重写的放法的权限修饰符不小于父类被重写的方法的权限修饰符.特殊情况:子类不能重写父类中声明private权限的方法.
3.返回值类型:父类被重写的返回值类型是void,子类重写的方法的返回值只能是void.父类被重写方法的返回值类型是A类型,则子类重写方法的返回值类型可以是A类或A的子类
父类被重写的方法的返回值类型是基本数值类型,则子类重写方法的返回值类型必须是相同类型
子类和父类中同名同参数的方法要么声明为非static,要么声明为static

super关键字使用
1.super可以用来调用:属性,方法,构造器
2.super的使用:1.在子类的方法或构造器中,通常使用super.属性或super.方法的形式,显示的调用父类中声明的属性或方法.2.特殊情况:当子类和父类定义了同名的属性时,想要在子类中调用父类的方法,就要标明super.属性的方式
3.在子类重写了父类的方法以后,想在子类的方法中调用父类中被重写的方法时,必须显示的使用super.方法,表明调用的是父类中被重写的方法
4.super调用构造器
1.可以在子类的构造器中显示的使用super(形参列表)的方式,调用父类中的声明指定构造器
2.super(形参列表)的使用,必须声明在子类构造器的首行
3.在类的构造器中,this(形参列表)和super(形参列表)只能二选一,不能同时出现
4.在构造器的首行,没有显示的声明this和super,默认调用的是父类中空参的构造器super
5.在类的多个构造器中,至少有一个类的构造器中使用了super(形参列表),调用父类中的构造器

子类对象实例化的过程
1.从结果上来看:(继承性)
子类继承父类以后,就获取了父类中声明的属性或方法
创建子类的对象,在堆空间中,就会加载所有父类中声明的属性
2.从过程上来看
通过子类的构造器创建子类对象时,直接或间接的使用其父类的构造器,进而调用父类的父亲的构造器,直到调用了object类的空参构造器为止,正因为加载过所有父类的结构
才可以看到内存中有父类中的结构,子类对象才可以考虑调用
明确:创建子类对象时,调用了父亲的构造器,就创建过一个对象,即为new的子类对象

设计原则
消除代码复制，增加可拓展性。 用封装来降低耦，类和类之间的关系称作耦合，耦合越低越好，保持距离是形成良好代码的关键。用接口来实现聚合。用容器和实现灵活性
以框架+数据来提高可拓展性。命令的解析是否脱离if——else。定义一个类来处理命令。用框架来保存命令与类之间关系
数据与表现分离。程序的业务逻辑与表现无关：表现可以是图形的也可以是文本的，表现可以是当地的也可以是远程的。
责任驱动的设计，将程序要实现的功能分配到合适的类或对象中去是设计中非常重要的一环。
main()方法的使用说明：
1.main（）方法作为程序的入口
2.main()方法也是一个普通的静态方法
3.main()方法可以作为我们与控制台交互的方式
网格化
类的成员：代码块（或初始块）
1.代码块的作用：用来初始化类，对象
2.代码块如果有修饰，只能使用static
3.静态代码块：内部可以有输出语句，随着类的加载而执行，只执行一次。作用：初始化类的信息。如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行。静态代码块的执行优先于非静态代码块的执行
静态代码块内只能调用静态的属性，静态的方法，不能调用非静态的结构
4.非静态代码块：内部可以有输出语句，随着对象的创建而执行，每创建一个对象，就执行一次非静态代码块。作用：可以创建对象时，对对象的属性进行初始化。如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
非静态代码块内可以调用静态的属性，静态的方法，或非静态的属性，非静态的方法
对属性可以赋值的位置：1.默认初始化。2.显示初始化。3.在代码块中赋值。4.构造器中初始化。5.有对象以后，通过“对象，属性”或“对象，方法”的方式，进行赋值
final关键字：可以用来修饰类，方法，变量。修饰一个类时：此类不能被其他类继承。修饰方法时：表明这方法不可以被重写。修饰变量时：变成了常量
final修饰局部变量：使用final修饰形参时，表明此形参是一个常量，调用此方法时，给常量形参赋一个实参，就只能在方法体内使用此形参，不能重新赋值
static final 用来修饰属性：全局常量

抽象与接口
抽象函数-表达概念而无法实现具体代码的函数。抽象类-表达概念而无法构造出实体的类。
带有abstract修饰符的函数，有抽象函数的类一定是抽象类，抽象类不能制造对象，但是可以定义变量，任何继承了抽象类的非抽象类的对象可以付给这个变量。
实现抽象函数，继承自抽象类的子类必须覆盖父类中的抽象函数，否则自己成为抽象类
两种抽象，与具体相对：表示一种概念而非实体。与细节相对：表示在一定程度上忽略细节而着眼大局
abstract修饰类：抽象类。1.此类不能实例化。2.抽象类中一定有构造器，便于子类实例化时调用。3.开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作
abstract修饰方法：抽象方法。1.抽象方法只有方法的声明，没有方法体。2.包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。3.若子类重写了父类中的所有抽象方法后，此子类才可实例化
若子类中没有重写父类中所有抽象方法，则子类也是一个抽象类，需要使用abstract修饰。
abstaract不能用来修饰：属性，构造器等结构，不能修饰私有方法，静态方法，final的方法，final的类

接口
接口是纯抽象类，所有的成员函数都是抽象函数public abstract，所有的成员变量都是public static final。（书写时可以省略）
接口规定了长什么样，但是不管里面有什么 用关键字 implements关联
接口不能定义构造器！意味着接口不能实例化
实现接口
类用extends，接口用implements，java类可以实现很多接口。接口可以继承接口(而且多继承），但不能继承类。接口不能实现接口。
如果implement类中覆盖了接口中所有抽象方法，则此实现类就可以实例化，如果实现类中没有覆盖接口中的所有的抽象方法，则此实现类仍为一个抽象类
JDK8以后：还可以定义静态方法，默认方法.1.接口中定义的静态方法，只能通过接口来调用
2.通过实现类的对象，可以调用接口中的默认方法，如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法。
3.如果子类继承的父类和实现的接口中调用了同名同参数的方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法
4.如果实现类实现了多个接口，而这多个接口定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，报错————接口冲突，这时候需要在类中重写此方法
接口的具体使用：多态性
面向接口的编程方式
设计程序时先定义接口，再实现类。任何需要再函数间传入传出的一定是接口而不是具体的类。

Swing使用一个非常灵活的模型来处理GUI的输入:采用事件监听器的事件处理(event handling)模型。
Swing框架本身以及大部分部件在发生一些情况时会触发相关的事件,而其他的对象也许会对这些事件感兴趣。不同类型的动作会导致不同类型的事件。
当点击一个按钮或选中一个菜单项,部件就会触发动作事件;而当点击或移动鼠标时,会触发鼠标事件;当框架被关闭或最小化时,会触发窗口事件。另外还有许多种其他事件

内部类就是指一个类A定义在另一个类B的内部，从而成为外部类的一个成员，类A是内部类，类B是外部类。因此一个类中可以有成员变量、方法，还可以有内部类。
实际上Java的内部类可以被称为成员类，内部类实际上是它所在类的成员。所以内部类也就具有和成员变量、成员方法相同的性质。
比如，成员方法可以访问私有变量，那么成员类也可以访问私有变量了。也就是说，成员类中的成员方法都可以访问成员类所在类的私有变量。内部类最重要的特点就是能够访问外部类的所有成员。
mi名类 在new对象的时候给出的类的定义形成了mi名类。可以继承某类，也可以实现某接口。Swing的消息机制广泛使用mi名类
内部类
定义在别的类内部，函数内部的类。内部类能直接访问外部的全部资源：包括任何私有的成员，外部是函数时，只能访问那个函数final的那个变量
注入反转
由按钮公布一个守听者接口和一对注册/注销函数，你的代码实现接口，将守听者对象注册在按钮上。一旦按钮被按下，就会反过来调用你的守听者对象的某个函数

JTABLE
用Jtable类可以以表格的形式显示和编辑数据，jtable类的对象并不存储数据，他只是数据的表现
MVC控制模式
数据，表现和控制三者分离，各负其责
M=model 模型 V=view（表现）C=control（控制） 模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新。表现：从模型获得数据
根据数据画出表现。控制：从用户得到输出，根据输入调整数据

异常处理与输入
异常 捕捉异常：将程序执行中发生的不正常情况
异常分为两类：1.error，java虚拟机无法解决的严重问题，除非改代码 2.exception：其他因编程错误或偶然的外在因素导致的一般性问题，使用针对性的代码进行处理
java下的throwable类有两个子类：error和exception类子类（编译时异常和运行时异常） try-catch处理编译时异常,但运行时可能报错
try{
   // 可能产生代码的异常
}catch (type1 id1){
   // 处理type1异常的代码
} catch (type2 id2){
   // 处理type1异常的代码
} catch（type3 id3）{
   // 处理type1异常的代码
}finally{
    //一定会执行的代码,即使catch中出现异常，或者try有return语句
} ps:finally 可选的 2.用try将可能出现异常的代码包装起来,根据对象异常的类型,去catch中进行匹配.3. 一旦处理完异常的代码,继续执行其后的代码4.catch中异常类型如果没有子父类关系,则位置关系无所谓.
异常捕获机制
有异常抛出——所处的是try 如是 看有catch匹配 如有 则继续下面的语句。如否 则推出到外层。 如所处的不是try，看所处的是否是函数
如是 则返回调用者，在判断是否所处的是try，在返回所处的是try。如所处的函数不是则退出到外层 。在判断所处的是否是try
拿到异常对象之后 String getMessage（）；String toString（）；void printStackTrace（）；e.getmessage() e.tostring e.printStackTrace
再度抛出异常 catch（exception e）{
   throw e；
}如果在这个层面上需要处理，但是不能做最终的决定
异常：有不寻常的事情发生了。当这个事情发生的时候，原本打算要接着做的事情不能在继续了，必须要停下来，让某个地方的某段代码来处理
异常机制最大的好处就是清晰的分开了正常的业务逻辑代码和遇到情况时的处理代码
异常声明
如果你的函数可能抛出异常，就必须在函数头部加以声明 void f() throws toobig，toosmall{ //...
}  void f（）{...}  可以声明并不会真的抛出异常
异常声明 如果你调用一个声明会抛出异常的函数，那么：把函数的调用放在try块中，并设置Catch来捕捉所有可能抛出的异常，或声明自己
会抛出无法处理的异常。
异常声明遇到继承关系：当覆盖一个函数的时候，子类不能声明抛出比父类版本更多的异常。在子类的构造函数中，必须声明父类可能抛出的全部异常
抛出异常：   程序在正常执行过程中，一旦出现异常，就会在异常代码生产一个对应异常类的对象，并将对象抛出，一旦抛出，其后代码不再执行
throws的对象 ：任何继承了Throwable类的对象。Exception类继承了Throwable，thow new Exception（）；throw new Exception（"helo"）
throws+异常类型，1.写在方法的声明处,指明此方法执行时,可能会抛出的异常类型.一旦当方法体执行时,出现异常,就i会在异常代码生成一个异常类对象.就会被抛出
try-catch:将真正异常处理掉了,throws只是将异常抛给了方法的调用者,并没有真正将异常处理掉
catch怎么匹配到异常的 Is——A的关系，抛出子类异常会被捕捉到父类异常的Catch给捉到
捕捉到任何异常Catch（EXCEPTION E){
   ...
}
运行时刻异常 有些异常是不需要声明的，但是如果没有适当机制来捕捉，就会导致程序终止。
使用try-catch还是throws?1.如果父类中被重写的方法没有throws方式处理异常,则子类重写的方法也不能使用throws,子类重写的方法中有异常,必须使用try-catch处理
2.执行的方法a中,先后的调用了几个方法,这几个是递进关系进行的,建议用thorws方式中去处理,a建议用try-catch去处理
关于异常对象的产生:1.系统自动生成的异常对象.2.手动生成的一个异常对象,并抛出throw
如何自定义异常类?1.继承于现有的异常结构2.提供全局常量serialVersionUID

流
流是输入输出的方式，流是一维单向的。
流的基础类：inputstream(read()...)，outputstream(write()...)
文件流
FileinputStream,FileoutputStream 对文件作读写操作，实际工程中很少使用，最常用的是在内存数据或通信数据上建立的流，如数据库的
二进制数据读写或网络端口通信。具体的文件读写往往有更专业的类，比如配置文件和日志文件
流过滤器
以一个介质流对象为基础层层构建过滤器流，最终形成的流对象能在数据的输入输出过程中，逐层使用过滤器流的方法来读写数据
Data DatainputStream DataoutputStream 用以读写二进制方式表达的基本数据类型的数据
文本输入输出
Reader/Writer 二进制数据采用inputStream/outputstream 文本数据采用Reader/Writer
在流上建立文本处理 printWriter pw = new printwriter（new bufferedwriter（new outputStreamwriter（new FileoutputStream（））
Reader 常用的时BUFFEREDReader: readline（）
LINENUMBERREADER 可以得到行号：getlinenumber（）
FILEREADER：inputStreamReader类的子类，所有方法都从父类中继承而来
FileReader（File file） 在给定从中读取数据的File的情况下创建一个新的FileReader
FileReader（String Filename） 在给定从中读取数据的文件名情况下创建一个新FileReader
fileREADER不能指定编码转换方式
汉字编码
inputStreamReader(inputstream in) 创建一个使用默认字符集的inputSTREmreader
inputStreamReader(inputstream in，Charset cs) 创建使用给定字符集的inputstreamreader
inputStreamReader(inputstream in，CharsetDecoder dec) 创建使用给定字符集解码器的inputstreamreader
inputStreamReader(inputstream in，String charsetName) 创建使用指定字符集的 inputstreamreader
数据是二进制的 用InputSream 表达的是文本 用Reader 否则用Scanner

流的应用
阻塞/非阻塞
read（）函数是阻塞的，在读到所需的内容之前会停下来等。使用read（）的更高级的函数 都是这样
常用单独线程来做socket读的等待，或使用nio的channel机制
对于socket可以设置SO时间 setsoTINEout（INT timeout）

Maven构建工具
由于jar包添加麻烦或工作量大。可以自动帮程序员下载第三方库（jar），完成整个项目编译（调用javac.exe），完成整个项目单元测试流程（调用junit工具），完成项目打包（调用jar.exe)
maven是一个构建工具，自动下载中心仓库的jar文件，存在本地进行管理，编译，测试，运行和打包发布java项目
Maven构建生命周期：清理，编译，测试，打包，安装，部署。

单元测试和JUNIT
测试
软件测试的经典定义：在规定的条件下对程序进行操作，以发现程序错误，并对其能满足设计要求进行评估的过程

单元和集成测试
单元测试，对软件中的最小可测试单元进行检测和验证，通常是一个函数/方法。单元测试是已知代码结构进行的测试，属于白盒测试。
集成测试是多个单元相互作用，形成一个整体，对整体协调性进行测试。一般从构成系统的最小单元开始，持续推进到单元之间的接口直到集成为一个完成的软件系统为止。

白盒和黑盒测试
白盒测试，全面了解程序内部逻辑结构，对所有的逻辑路径进行测试，一般由程序员完成。
黑盒测试，在完全不考虑此程序内部结构和内部特性的情况下，检查程序功能是否按照需求规格说明书的规定正常使用，一搬由独立的使用者完成。

自动和手动测试
自动测试：用程序批量反复测试程序，并可自动检查程序结果是否满足预定的要求
手动测试：手动执行程序，手动输入所需要的参数，手动检查程序结果是否满足预定的要求

回归测试
回归测试：修改旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误
回归测试在整个软件的是过程中占有很大比重。软件快速迭代开发过程中，新版本的连续发布使得回归测试进行的更加频繁
测试策略
基于main函数的策略
优点：简单 缺点：无法自动判断被测对象的行为是否符合预期。main方法需要添加大量的代码。分散程序员在开发时的关注点
基于自动化测试框架的策略
初始化，输入测试数据执行被测代码，获取系统实际结果，比较结果是否一致，输出测试结论
JUnit：一个Java语言的单元测试框架
import static：导入某一个类的所有静态方法；import是导入一个类或者几个类

高级文本处理
字符编码:字符，ASCII码：用一个字节来存储a-z，A-Z，0-9和一些常用符号。回车键（13，00001101），0（48，00110000），A（65，01000001），a（97，01100001）
ASCII编码采用1bit，8bit，最多256个字符
中文编码：GB2312,GBK,GB18030,BIG5,GB18030>GBK>GB2312
UNICODE编码：存储全世界所有字符。编码方案：UTF-8，兼容ASCII，变长。UTF-16.用2-4个字节存储所有字符。UTF-32，用32Bits存储所有字符
JAVA的字符编码：源文件编码：采用UTF-8编码。程序采用UTF-16编码存储所有字符。和\

Java国际化编程
多语言版本的软件：一套软件，多个语言包。根据语言设定，可以切换显示文本。
Java是第一个设计成支持国际化的编程语言。java.util.ResourceBundle 用于加载一个语言-国家语言包。java.util.Locale定义一个语言-国家
Locale类
Locale语言，zh，en等。Locale方法：getAvailableLocales()返回所有可用的Locale。getDefault（）返回默认的Locale
语言文件
一个properties文件，包含K-V对，每行一个K-V。命名规则：包名+语言+国家地区.properties。存储文件必须是ASCII文件，如果是这以外文件，必须用Unicode的表示。可以用native2ascii.exe进行转码
ResourceBundle类
根据Locale要求，加载语言文件。存储语言集合中所有K-V对。getString返回对应的Value。根据key找value的查找路径。
Locale：由语言和国家/地区组合起来的。所有的PROPERTIES文件形成一个树。指定Locale后，ResourceBundle就形成一个树：先找到第一个节点文件（搜索路径），将该节点所有父节点文件全部加载。根据所找到的文件内容和KeY,返回相应的值
其他国际化：日期/时间国际化DateTimeFormatter和Locale的结合。数字/金融国际化.NumberFORmat和Locale结合

Java高级字符串处理
正则表达式：用事先定义好的一些特定字符及特定字符的集合，组成一个“规则字符串”，作用：测试字符串内的模式，识别替换文本。提取文本。正则表达式独立于特定语言。
Java.util.regex包：-pattern正则表达式的编译显示，–Pattern 正则表达式的编译表示
• compile 编译一个正则表达式为Pattern对象
• matcher 用Pattern对象匹配一个字符串，返回匹配结果
–Matcher
• Index Methods(位置方法) // start(), start(int group), end(), end(int group)
• Study Methods(查找方法) // lookingAt(), find(), find(int start), matches()
• Replacement Methods(替换方法) //replaceAll(String replacement
字符串和集合互转
–[1,2,3], “1,2,3”
• 字符串转义
–对关键字符转义
• 变量名字格式化
–名字驼峰命名
• 字符串输入流
–将字符串转为一个输入流
–输入流可以定义为Scanner，这是Online Judge的实现原理

多线程
线程是一个程序内部的一条执行路径
若一个进程同一时间并行执行多个线程就是支持多线程的。
线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小
一个进程中的多个线程共享相同的内存单元和内存地址空间， 他们从同一堆中分配对象，可以访问相同的变量和对象。
并行：多个CPU同时执行多个任务。 并发：一个CPU同时执行多个任务
多线程的创建：方式一：1.创建一个继承于Thread类的子类2.重写Thread类方法run()此线程的执行的操作写在方法中3.创建Thread类的子类的对象4.通过此对象调用start().ps.可以创建新的对象去多线程执行
Thread常用方法1.start启动当前线程 2.run将创建的线程要执行的操作声明在此方法中 3.currentThread():静态方法,返回执行当前代码的线程 4.getname:获取当前线程名字.5.setname:设置当前线程的名字
6.yield():释放当前cpu的执行权 7.join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态,直到线程b执行完后,a才执行.8.stop():强制结束当前线程
9.sleep:让当前线程睡眠指定毫秒.10.isAlive:()判断当前线程是否存活

线程的优先级:1.MAX:10 MIN:1 NORMAL:5
如何获取和设置当前线程的优先级:getPriority() setPriority()
高优先级线程抢占低优先级线程cpu的执行权,高优先级线程高概率情况下被执行.

创建多线程的方式二:实现Runnable接口
1.创建一个实现了Runnable接口的类
2.实现类去实现Runnable中的抽象方法Run()
3.创建实现类的对象
4.将此对象作为参数传递到Thread类的构造器汇总,创建Thread类的对象
5.通过Thread类的对象调用start()
两种创建方式的比较:开发中优先使用Runnable接口的方式,原因:1.实现方式没有类的单继承性和局限性.2.实现的方式更适合多个线程共享数据的情况
相同点:两种方式都要重写run()

线程的生命周期
JDK中用Thread.State类定义了线程的几种状态:1.新建:当一个Thread类或其子类对象被声明创建时,新生的线程对象处于新建状态
2.就绪:处于新建状态的线程被start()后,将进入线程队列等待CPU时间片,此时它已经具备运行的条件,只是没分配到CPU资源
3.运行:当就绪的线程被调度并获得CPU资源时,便进入运行状态.run()方法定义了线程的操作和功能
4.阻塞:在某种特殊情况下,被人为挂起或执行输入输出操作时,让出CPU并临时中止之间的执行,进入阻塞状态 方法有sleep(long time) join() 等待同步锁 wait() suspend()
5.死亡:线程完成了它的全部工作或线程被提前强制终止或出现异常导致结束

线程的安全问题
当某个线程操作过程中,尚未操作完成时,其他线程也参与进来.
如何解决:当一个线程操作时候,其他线程不能参与进来,直到线程a操作完时,其他线程才可以开始操作,即使线程出现了阻塞,也不能改变
通过同步机制,来解决线程的安全问题
方式一:同步代码块
synchronized(同步监视器){
  //需要被同步的代码
}ps:操作共享数据的代码,就是被同步的代码 共享数据:多个线程共同操作的变量.
同步监视器(锁):任何一个类的对象.要求:多个线程必须共用同一把锁
同步的方式,解决了安全问题,但是操作同步代码时,只能有一个线程参与,其他线程等待,相当于一个单线程的过程
在实现Runnable接口创建多线程的方式中,考虑使用this充当同步监视器.慎用this充当,考虑使用当前类来充当

方法二.同步方法
如果操作共享数据的代码完整的声明在一个方法中,可以将此方法声明同步的 public synchronized void run(){}
使用同步方法处理继承Thread类的方式中的线程安全问题extends Thread类 声明static
summarize:同步方法设计到同步监视器,只是不需要显示声明
2.非静态的同步方法,同步监视器是this
静态的同步方法,监视器是当前类本身

线程的死锁问题
理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
说明：1.出现死锁后，不会出现异常，不会出现提示，只是所有线程处于阻塞状态，无法继续
2.使用同步时，避免出现死锁
解决：1.专门的算法，原则 2。尽量减少同步资源的定义。3.尽量避免嵌套同步

锁
通过显示定义同步锁对象来实现同步，同步锁使用lock对象充当
java.util.concurrent.Lock接口是控制多个线程对共享资源进行访问的工具,锁提供了对共享资源的独立访问,每次只能由一个线程对Lock对象加锁,线程开始访问共享资源之前都先获得Lock对象
ReentrantLock类实现了Lock,拥有与synchronized相同的并发性和内存语义,在实现线程安全的控制中,比较常用的是ReentrantLock
1.实例化ReentrantLock
2.调用锁定方法lock()
3.调用解锁方法:unlock()

synchronized与lock的异同
解决线程安全问题.不同:synchronized机制在执行完相应的同步代码以后,自动的释放同步监视器
lock需要手动的启动同步lock(),结束同步也需要手动的实现unlock()

线程的通信
例子:交替打印
三个方法:
1.wait():一旦执行此方法,当前线程就进入阻塞状态,并释放同步监视器
2.notify():一旦执行此方法,就会唤醒wait的一个线程,如果多个线程被notify,就选择优先级那个
3.notifyall():唤醒所有被wait的线程
说明:1.三个方法必须使用在同步代码块或同步方法中
2.三个方法的调用者必须是同步代码块或同步方法中的同步监视器,否则出现IlleagalMonitorStateException异常
3.此三个方法都定义在object类中

sleep和wait的异同
1.相同:都可以使得当前线程进入阻塞状态
2.不同:1.两个方法声明的位置不同:THread类中sleep(),object类中wait()
2,调用范围不同:sleep()在任何场景下调用,wait必须在同步代码块或同步方法
3.sleep不会释放监视器,wait会释放监视器

新增线程接口
方式三:实现Callable接口
相比run方法,有返回值.
方法可以抛出异常
支持泛型的返回值
需要借助FutureTask类 Future接口,可以对具体Runnable和callable任务的执行结果进行取消,查询是否完成,获取结果等
FutrueTask是Futrue接口的唯一实现类
FutrueTask同时实现了Runnable,Future接口,既可以作为Runnable线程执行,又可以作为Future得到Callable的返回值
步骤:1.创建一个实现Callable的实现类
2.实现call方法,将此线程需要执行的操作声明在call()中
3.创建Callable接口实现类的对象
4.将此Callable接口实现类的对象作为传递到FutureTask构造器中,创建futuretask的对象
5.将futuretask的对象作为参数传递到thread类的构造器中,创建thread对象,并调用start
6.获取callable中call方法的返回值

方式4:使用线程池
思路:提前创建好多个线程,放入线程池中,使用时直接获取,使用完放回池中,可以避免频繁创建销毁,实现重复利用
corePoolSize:线程池的大小  maxmunPoolSzie:最大线程数 keepAliveTime:线程没有任务时最多保持多长时间后终止
1.提供指定线程数量的线程池        ExecutorService Service = Executors.newFixedThreadPool(10);
2.执行指定线程的操作,需要提供实现Runnable接口或Callablle接口实现类的对象
Service.execute(new NumberThread());//适合使用于runnable
//        Service.submit();//适合使用于callable
3.关闭连接池 Sevice.shutdown();
PS:管理线程池  ThreadPoolExecutor service1=(ThreadPoolExecutor) Service;
                service1.setCorePoolSize(15);

Java常用类
字符串String类
String是一个final类，代表不可变的字符序列,不可被继承
2.String实现了Serializable接口：表示字符串支持序列化 实现了Comparable接口，表示可以比较大小
3.String内部定义了final char[] value用于存储字符串数据
4.字符串常量池中不会存储相同内容的字符串
5.当对字符串重新赋值时,需要重写指定内存区域赋值,不能使用原有的value进行赋值
6.当对现有的字符串进行连接操作时,也需要重新指定内存区域的赋值,不能使用原有的值
7.当调用String的replace()方法修改指定字符或字符串时,也需要重新指定内存区域

String实例化方式
1.通过字面量定义的方式 数据JavaEE声明在方法区中的字符串常量池中
2.通过new+构造器的方式 数据在堆空间中开辟空间以后对应的值
常量与常量的拼接结果就在常量池中，且常量池中不会存在相同内容的常量
只要其中一个是变量，结果就在堆中，如果拼接的结果调用intern方法，返回值就在常量池中

String常用方法
length():返回字符串
charat():返回某处字符
isEmpty：判断是否为空
tolower（upper）case：将字符串转换为大小写
trim():忽略字符串的前端后端的空白
equal:比较内容是否相等
concat:将指定字符串连接到结尾
compareTo:比较两个字符串大小
substring:返回一个新的字符串,可选取内容
endwith:测试字符串是否已指定后缀结束
startswith:字符串是否以指定前缀结束
contains:检测是否包含字符串,如有返回true
indexof:返回子字符串在字符串第一次出现的索引
lastindexof:返回子字符串在字符串最后一次出现的索引
replace:根据正则表达式替换指定字符
matches:根据正则表达式匹配指定字符
spilt:根据正则表达式分割指定字符

String类与其他结构之间转换
String---> 基本数据类型,包装类:调用包装类的静态方法:parseXXX(str)
基本数据类型,包装类-->String:调用String重载方法valueof(xxx)
String-->char[]之间转换:调用String的toCharArray()
Char[]-->String:调用String的构造器
String-->byte[]之间转换:调用String的getBytes()
byte[]-->String:调用String的构造器
编码:字符串-->字节  解码:字节-->字符串

StringBuffer，StringBuilder类
String：不可变的字符序列，底层使用char[]数组存储
StringBuffer：可变的字符序列;线程安全，效率低;new对象时new char[] value[16];底层创建了一个char型数组.new StringBuffer=new char["abc".length]
StringBuilder:可变的字符序列 线程不安全，效率高
扩容问题:默认情况下,扩容为原来容量的2倍+2,同时将原有数组中的元素赋值到新的数组
常用方法:
append:用于字符串拼接
delete:删除指定位置的内容
replace:把位置替换为str
insert:在指定位置插入
reverse:把当前字符序列逆转

日期时间API
system类中方法currentTimeMills(),返回当前时间与1970年1月1日之间以毫秒为单位的时间差,称为时间戳
Java.util.Date类
1.两个构造器的使用(1)Date():创建一个对应当前时间的Date对象 (2)new Date(long Date);
2.两个方法使用:tostring()显示当前年月日时分秒
gettime():获取当前对象对应的毫秒数

java.sql.date对应着数据库中日期类型的变量
将java.util.Date对象转换为java.sql.Date对象
Date new一个date 再将sql.date的对象强制转为为(java.sql.Date)date

SimpleDateFormat的使用
1.两个操作：格式化：日期——>字符串 format方法
解析：格式化逆过程 字符串-->日期 parse方法
2.SimpleDateFormat的实例化,调用方法
带参的构造器格式(yyyy-MM-dd hh:mm:ss)

cALENDA日历类
1.实例化
（1）创建其子类（GregorianCalendar）的对象
（2）调用其静态方法getInstance（）
2.常用方法
get（）
       calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(calendar.get(Calendar.DAY_OF_YEAR));
set（）
calendar.set(Calendar.DAY_OF_YEAR, 22);
add（）
calendar.add(Calendar.DAY_OF_YEAR,3);
gettime（）日历类--》Date
sertime（）Date--》日历类

LocalDate，LocalTime，LocakDateTime的使用
 方法：       now（）：获取当前日期，时间，日期+时间
        LocalDate now = LocalDate.now();
        LocalTime now1 = LocalTime.now();
        LocalDateTime now2 = LocalDateTime.now();
方法：of():设置指定的年，月，日，时，分，秒
LocalTime of = LocalTime.of(12, 30);
方法：getxxx（）；获取当前属性的值
withDayofMouth（）；修改时间，体现不可变性
plusxxx（）；加属性的值  minusxxx（）：减属性的值

Instance类的使用
now（）：放回utc时区的对象. ofHours():添加时区偏移量 toEpochMilli（）：获取毫秒数从1970年1月1日开始

DateTimeFormatter类：格式化或解析日期，时间
方式一：预定义的日期格式
                    DateTimeFormatter isoLocalDateTime = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
                    String s1=isoLocalDateTime.format(of)
二：本地化相关格式：ofLocalLizedDate（）
三：自定义的格式 ofPattern（“yyyy-MM-dd hh：mm：ss）
格式化

Java比较器
Java中对对象中进行排序，实现两个接口中的一个：Comparable或Comparator
1.Comparable接口使用 自由排序
(1)像Sring,包装类实现类Comparable接口,重写了compareTo()方法,给出了两个比较大小
(2)重写compareTo()的规则:
如果当前对象this大于形参对象obj,则返回正整数
如果当前对象this小于形参对象obj,则返回父整数
如果当前对象this等于形参对象obj,则返回0
(3)对于自定义类,如果需要排序,可以实现compale接口,重写compareto()方法
2.定制排序：java.util.comparator
当元素类型没有实现Comparable接口又不方便修改代码,或者实现了接口排序规则不适合当前规则,可以使用Comparator接口
重写Compare(obj ob1,obj ob2),比较o1和o2大小
返回正整数,表示o1大于o2
返回0,表示相等
返回负整数,表示o1小于o2

两者对比:
Comparable接口一旦一定,任何位置都可以比较大小
comparator可以临时性的比较

枚举类
类的对象只有有限个，确定的。当需要定义一组常量时，建议使用枚举类
2.如果枚举类中只有一个对象，可以作为单例模式的实现方式
如何定义枚举类
方式一：jdk5.0之前，自定义枚举类:(1)声明对象的属性Private final（2）私有化类构造器，并给对象赋值（3）提供当前枚举类的多个对象：public static final（4）获取枚举类对象的属性
方式二：5.0，可以使用enum关键之定义枚举类 enum **{
        对象名字(构造器属性);
        对象名字(构造器属性);
        对象名字(构造器属性);
}

enum中的常用方法:
values()方法:返回枚举类型的对象数组
valueof(String str):把一个字符串转为对应的枚举类对象,要求枚举类对象
tostring:返回当前常量的名称

注解Annotation（代码的特殊标记，可以编译，类加载，运行时读取等）
架=注解+反射+设计模式
示例一：生成文档相关的注解
实例二：在编译时进行格式检查：1.Override：限定重写父类方法，只用于方法。2.Deprecated：用于表示所修饰的元素已过时。3.SuppressWarnings：抑制编译器警告
示例三：跟踪代码依赖性，实现替代配置文件功能
3.如何自定义注
参照@SuppressWarining直接去定义
1.注解声明为@interface
2.内部定义成员，通常使用value表示
3.可以指定成员的默认值，使用default定义
4.如果自定义注解没有成员，表明只是一个标识作用
如果注解有成员，在使用注解时，需要指明成员的值
自定义注解必须配上注解的信息处理流程（使用反射）才有意义

4.元注解
修饰注解的注解
Retention：指定所修饰的注解的声明周期：source\CLASS(默认行为）\ RUNTIME
只有声明为RUNTIME生命周期的注解，才能通过反射获取
Target:用于指定被修饰的注解能用于那些程序元素
Documented：表示所修饰的注解在javadoc解析时，保留下来
Inherited：被它修饰的Annotation将具有继承性

java8新特性：
1.可重复注解:(1)在注解上声明@Repeatable.成员值为注解.class.
(2)注解的Target和Retention和my注解相同
2.类型注解
ElementType.TYPE_PARAMETER表示该注解能写在该类型变量的声明语句中(如泛型声明)
ElementType.TYPE_USE 表示该注解能卸载使用类型的任何语句中

java集合
1.集合,数组都是多个数据进行存储操作的结构,简称java容器
说明:此时的存储,主要指的时内存层面的存储,不涉及到持久化的存储
2.1 数组在存储多个数据方面的特点:
一旦初始化后,其长度就确定
数组一旦定义好,其元素的类型也就确定了,只能操作指定类型的数据了
比如:String[];int[];Object[];
2.2 数组在存储多个数据方面的特点:
一旦初始化后,长度就不能修改.
数组中提供的方法非常有限,对于添加,删除,插入数据等操作,效率不高
获取数组中实际元素的个数的需求,数组没有现成的属性或方法可用
数组存储数据的特点:有序,可重复,对于无序,不可重复的需求,不能满足

java集合可分为Collection和map两种体系
1.Collection接口:单列数据,定义了获取一组对象的方法的集合.
----List:元素有序,可重复的集合."动态数组"
    ---ArrayList,LinkedList,Vector
----Set:元素无序,不可重复的集合.
    ---HashSep,LinkedHashSet,TreeSe.t
2.Map接口:双列数据,保存具有映射关系"Key-value对"的集合`````
----HashMap,LinkedHashMap,TreeMap,Hashtable,Properties

Collection接口中的方法使用:向Collection接口的实现类中的对象中添加数据obj时,要求obj所在类重写equals()
add(Object e):将元素e添加到集合coll中
size():获取添加的元素的个数
addAll(collection coll1):将coll集合中的元素添加到当前的集合中
clear():清空集合元素
isEmpty():判断当前集合是否为空
contains(Object obj):判断当前集合中是否包含obj;判断时调用obj中的equal方法.
containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在当前集合中
remove(Object obj):从当前集合中移除obj元素
removeAll(Collection coll1):从当前集合中移除coll1中所有的元素
retainAll(Collection coll1):获取当前集合和coll1集合的交集,并返回给当前集合
equals(Object obj):判断当前集合和形参是否相同,如相同,则返回true
hashCode():返回当前对象的哈希值
集合-->数组:toArray()
数组-->集合:调用Arrays类的静态方法asList()

iterator():返回Iterator接口的实例,用于遍历集合元素.
集合元素的遍历操作，使用迭代器Iterator接口
报异常:nosuchElementException()异常
内部的方法:hashNext和next();遍历元素
内部定义了remove(),可以在遍历的时候,删除集合中的元素,此方法不同于集合中remove()
如果还未调用next()或在上一次调用next方法之后已经调用了remove方法,在调用remove都会报IllegalStateException
for-each循环(集合元素的类型 局部变量:集合对象);内部调用了迭代器

List接口
----List:元素有序,可重复的集合."动态数组"
---ArrayList：作为List接口的主要实现类，线程不安全的，效率高。底层使用Object[]ElementData存储
---LinkedList:底层使用双向链表存储,对于频繁的插入和删除操作,效率比ArrayList高;
---Vector：作为List接口的古老实现类，线程安全的，效率低。底层使用Object[]ElementData存储
三者的异同
同：都实现了List接口，存储数据的特点相同：存储有序，可重复的数据

ArrayList的底层源码分析:
java7的情况如下:
ArrayList list=new ArrayList();底层创建了长度是10的object[]数组
List.add(123);//ElementData[0]=new Integer(123);如果此次的添加导致底层数组容量不够,则扩容
默认情况下,扩容为原来容量的1.5倍,同时将原有数组中的数据复制到新的数组中
建议开发中使用带参的构造器ArrayList list=new ArrayList(int capacity);
JDK8的情况如下:
ArrayList list=new ArrayList();//底层Object[]elementData初始化为{},并没有创建为10的数组
List.add(123);//第一次调用add时,底层才创建了长度为10的数组,并将数据添加到element中
jdk7中的创建对象类似于单例的饿汉式,而jdk8中的对象创建类似于单例的懒汉式,延迟了数组的创建,节省内存

LinkedList的源码分析：
LinkedList list=new LinkedList();内部声明了Node类型的first和last属性,默认值为null
list.add();//将数据封装到node中,创建了Node对象,体现了双向链表的说法
Node定义为:   private static class Node<E> {
                E item;
                Node<E> next;
                Node<E> prev;

                Node(Node<E> prev, E element, Node<E> next) {
                    this.item = element;
                    this.next = next;
                    this.prev = prev;
                }
            }

Vector源码的分析:
通过Vector()构造器创建对象时,底层都创建了长度为10的数组,在扩容方面,默认扩容为原来的数组长度的2倍

List接口中的常用方法:
1.void add(int index,Object ele):在index位置插入ele元素
2.boolean addAll(int index,object ele):从index位置开始将eles中所有元素添加进来
3.get(int index):返回所在index位置的元素
4.int indexof(Object obj):返回obj在集合中首次出现的位置,如果不存在,则返回-1
5.int lastindexof(Object obj):返回obj在集合中最后出现的位置,如果不存在,则返回-1
6.remove(Object obj):从当前集合中移除obj元素,并返回元素
7.Object set(int index,Object ele):设置指定的index位置的元素为ele
8.List sublist(int fromIndex,int toIndex):返回从fromIndex到toIndex位置的左闭右开的集合
总结常用方法：
增：add(Object obj)
删:remove(int index)/remove(Object obj)
改:set(int index,ele)
查:get(int index)
插:add(int index,ele)
长度:size()
遍历:1.Iterator迭代器
2.增强for循环
3.普通循环

----Set:元素无序,不可重复的集合.
    ---HashSet:作为Set接口的主要实现类;线程不安全的;可以存储null值
        ----LinkedHashSet:作为HashSet的子类;遍历其内部数据时,可以按照添加的顺序遍历
    ----TreeSet:可以按照添加对象的指定属性,进行排序
1.Set接口中没有额外定义新的方法,使用的都是Collection中声明过的方法
2.无序性:不等于随机性.存储的数据在底层数组中并非按照数组索引的顺序添加.而是根据数组的哈希值决定的
3.不可重复性:保证添加的元素按照equals()判断时,不能返回true.即相同的元素只能添加一个
4.要求：向Set中添加的数据，其所在的类一定要重写hashCode()和equals()
要求:重写的hashCode()和equals()尽可能保持一致性:相等的对象必须具有相等的散列码
小技巧:对象中用作equals()方法比较的Field,都应该用来计算hashCode

二.添加元素的过程:以HashSet为例:
底层容量为16,当使用率超过0.75,就会扩大容量为原来的2倍
向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法,计算元素a的哈希值,
此哈希值接着通过某种算法计算出HashSet底层数组中的存放位置(即为:索引位置),判断数组在此位置上是否已经有元素
如果此位置上没有其他元素,则元素a添加成功---1
如果此位置上有其他元素b(或以链表形式存在的多个元素),则比较元素a,b的hash值
如果hash值不相同,则元素a添加成功---2
如果hash值相同,则需要调用元素a所在类的equlas()方法;
  equlas()返回true,添加失败;如返回false,则添加成功----3
对于2和3而言:元素a与已经存在指定索引位置上数据以链表的方式存储
jdk 7:元素a放到数组中,指向原来的元素
jdk8:原来的元素在数组中,指向元素a
HashSet底层:数组+链表

LinkedHashSet的使用
作为HashSet的子类,在添加数据的同时,每个数据还维护了两个引用,记录此数据前数据和后一个数据
对于频繁遍历操作,效率高于HashSet

TreeSet的使用
1.向TreeSet中添加的数据,要求是相同类的对象
2.两种排序方式:自然排序和制定排序
3.自然排序中,比较两个对象中是否相同的标准为:compareTo()返回0,不再是equals()
4.定制排序中,标准为:Compare返回0,不再是0

Map接口
Map：双列数据，存储Key-value对的数据
    ----HashMap：作为Map的主要实现类；线程不安全的，效率高；存储null的Key和Value
        ----LinkedHashMap:保证在遍历元素时，按照添加顺序实现遍历；原因：在原有HashMap基础上，添加了一对指针，指向前一个元素和后一个与元素
        对于频繁的遍历操作，此类效率高于HashMap
    ----TreeMap：按照添加的key-value对进行排序，实现排序遍历，此时考虑key的自然排序和定制排序
                底层使用红黑树，
    ----Hashtable：作为古老的实现类；线程安全，效率低；不能存储null的key和Value
        ----Properties：常用来处理配置文件。KEY和VALUE 都是String类型

HashMap的底层：数组+链表（jdk7之前）
               数组+链表+红黑树（jdk8）

二.Map结构的理解:
Map中的key:无序的,不可重复的,使用set存储所有的key --->key所在的类要重写equals()和HashCode()(以HashMAp为例)
Map中的Value:无序的,可重复的,使用Collection存储所有的Value -->value所在的类要重写equals()
一个键值对:key-value构成一个Entry对象
Map中的entry:无序的,不可重复的的,使用set存储所有的entry

HashMao的底层实现原理,以jdk7为例
HashMap map=new HashMap();
在实例化后,底层创建了长度是16的一维数组Entry[] table
...可能已经执行过多次put...
map.put(k1,vak1);
首先,调用key1所在类的hashcode()计算key1哈希值,经过某种算法计算以后,得到Entry数组中的存放位置
如果此位置上数据为空,此时k1--val1添加成功
如果此位置上数据不为空,(意味着此位置上村子啊一个或多个数据),比较key1和已经存在一个或多个数据的哈希值:
如果Key1的哈希值与此位置已经存在的哈希值不相同,此时添加成功  ---情况2
..............和已经存在的某一个数据的哈希值相同,调用equals()方法,比较
        如果equals返回False,此时添加成功    ----情况3
        如果返回True,使用value替换相同的value值
关于2和3:此时key1-value1和原来数据以链表方式存储
在添加过程中,默认扩容方式:扩容为原来的2倍,并将原来数据复制过来

JDK8
1.new HashMap():底层没有创建一个长度为16的数组
2.底层数组是:Node[] 而非Entry[]
3.首次调用put方法,创建长度16的数组
4.底层结构:数组+链表+红黑树
当数组某一个索引位置上的元素以链表形式存在数据个数>8且长度>64时,此索引位置上所有数据改为红黑树存储
DEFAULT_INITIAL_CAPACITY:HashMap的默认容量 16
DEFAULT_LOAD_FACTOR:默认加载因子:0.75
threshold:扩容的临界值,=容量*填充因子:16*0.75=12
TREEIFY_THRESHOLD:Bucket中链表长度大于该默认值,转化为红黑树:8
MIN_TREEIFY_CAPACITY:桶中的node被树化时最小的hash表容量64

LinkedHashMap的底层实现原理
static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;//能够记录添加的元素的先后顺序
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }


Map中常用方法
添加，修改，删除操作：
Object put(Object key,Object value):将指定key-value添加到或修改当前map对象中
void putAll(Map m):将m中所有key-value对存放到当前map中
Object remove(Object key):移除指定key的key-value对,并返回value
void clear():清空当前map中的所有数据
元素查询的操作:
Object get(Object key):获取指定key对应的value
boolean containsKey(Object key):是否包含指定的key
boolean containsValue(Object value):是否包含指定的value
int size():返回map中key-value对的个数
boolean isEmpty():判断当前map是否为空
boolean equals(Object obj):判断当前map和参数对象是否相等
元视图操作的方法:
Set keySet():返回所有key构成的Set集合
Collection values():返回所有value构成的Collection集合
Set entrySet():返回所有key-value对构成的set集合

Treemap两种添加方式的使用
向Treemap中添加key-value，要求key是由同一个类创建的对象
按照key进行排序：自然排序，定制排序

Map实现类之五：Properties
Properties类是Hashtable得子类，该对象用于处理属性文件
Properties里得key和value都是字符串类型
存取数据时，建议使用setProperty（String key，String value）方法和getProperty（String key）方法

Collections工具类：操作Collection和map的工具类
方法：1.reverse(list):反转List中元素的顺序
2.shuffle(List):对list集合中元素进行随机排序
3.sort(List):根据元素的自然顺序对指定的List集合元素按升序排序
4.sort(List,Comparator):根据指定的Comparator产生的顺序对list集合元素进行排序
5.swap(List,int,int):将指定list集合中的i处元素和j处元素进行交换
6.Object max(Collection):根据元素的自然顺序,返回给定集合中的最大元素
7.Object max(Collection,Comparator):根据Comparator指定的顺序,返回给定集合中的最大数
8.Object min(Collection)
9.Object min(Collection,Comparator)
10.int frequency(Collection,Object):返回指定集合中的指定元素的出现次数
11.void copy(List dest,List src):将src中的内容复制到dest中
12.boolean replaceAll(List list,Object oldVal,Object newVal):使用新值替换List中的老值\
Collections类中提供了多个synchronizedXxx()方法,该方法可使指定集合包装称线程同步的集合,从而可以解决多线程并发访问集合的线程安全问题

泛型
JDK1.5之前只能把元素设计成Object，1.5之后使用泛型来解决。
把元素的类型设计成一个参数，这个类型参数叫做泛型。允许在定义类，接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类。在使用时确定。
2.在集合中使用泛型：（1）集合接口或集合类在jdk5.0时都修改为带泛型的结构（2）在实例化集合类时，可以指明具体的泛型类型（3）指明完以后，在集合类或接口凡是定义类或接口时，内部结构使用到类的泛型都是指明的类型
比如：add（E e）（4）注意泛型的类型必须是一个类，不能是基本数据类型，需要用到基本数据类型的拿包装类
（5）如果实例化时，没有指明泛型的类型，默认为Object类型
3.如何自定义泛型结构:泛型类,泛型接口;泛型方法
(1)如果定义了泛型类,实例化没有指明类的泛型,则认为此泛型类型为Object类型
要求:如果大家定义了类是带泛型的,建议在实例化时指明类的泛型
(2)由于子类在继承带泛型的父类时,指明了泛型类型,则实例化子类对象时,不再需要指明泛型
(3)泛型不同的引用不能相互赋值(4)泛型要使用就一直用(5)静态方法中不能使用泛型(6)异常类不能是泛型的
4.子类不保留父类的泛型(1)没有类型擦除 class son<a,b> extends Father (2)具体类型 class son2<A,B> extends Fathe<Integer,String>
子类保留父类的泛型(1)全部保留 class son3<T1,T2,A,B> extends Father<T1,T2>(2)部分保留 class Son<t2,a,b> extends Father<Integer,T2>

泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。泛型方法所属的类是不是泛型都没有关系.泛型方法在调用时，指明泛型参数的类型。
可以声明为静态的，泛型参数是在调用方法时确定的，而非在实例化时使用的

1.泛型在继承方面的体系
类A是类B的父类，G<A>和G<B>二者并不具备字符类关系,二者是并列关系.
补充:类A是类B的父类,,A<G>是B<G>的父类
2.通配符的使用
通配符:?
类A是类B的父类,G<A>和G<B>是没有关系的,二者共同的父类是:G<?>
添加:对于List<?>就不能向其内部添加数据,除了添加null之外
获取(读取):允许读取数据,数据类型为Object.
3.有限制条件的通配符的使用
? extends A:G<? extends A>可以作为G<a>和G<B>的父类的,其中B是A的子类
? super A:G<? super A> 可以作为G<A>和G<B>的父类,其中B是A的父类


p577